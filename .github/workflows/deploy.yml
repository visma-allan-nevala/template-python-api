# =============================================================================
# CD Workflow - Build and Deploy
# =============================================================================
# This workflow builds and deploys the application after tests pass.
# Triggered on push to main branch (after test workflow succeeds).
#
# LLM Instructions:
# - Configure REGISTRY_URL and IMAGE_NAME for your container registry
# - Add deployment steps for your infrastructure (K8s, ECS, etc.)
# - Secrets needed: REGISTRY_USERNAME, REGISTRY_PASSWORD
# - For AWS ECR: Use aws-actions/amazon-ecr-login instead
# - For GitHub Container Registry: Use ghcr.io/${{ github.repository }}
# =============================================================================

name: CD

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production

# Only allow one deployment at a time
concurrency:
  group: deployment-${{ github.ref }}
  cancel-in-progress: false

env:
  PYTHON_VERSION: "3.12"
  # TODO: Configure your container registry
  REGISTRY_URL: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ---------------------------------------------------------------------------
  # Build and Push Docker Image
  # ---------------------------------------------------------------------------
  build:
    name: Build and Push
    runs-on: ubuntu-latest
    # Only run after tests pass
    # Uncomment when test workflow is configured:
    # needs: [test]

    permissions:
      contents: read
      packages: write

    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate version
        id: version
        run: |
          # Generate version: 0.1.0-rc.{run_number}
          echo "version=0.1.0-rc.${{ github.run_number }}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ steps.version.outputs.version }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha,prefix=

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ steps.version.outputs.version }}

  # ---------------------------------------------------------------------------
  # Deploy to Development
  # ---------------------------------------------------------------------------
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main'
    environment: development

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # TODO: Add deployment steps for your infrastructure
      # Examples:
      #
      # For Kubernetes:
      # - name: Deploy to Kubernetes
      #   run: |
      #     kubectl set image deployment/my-api \
      #       my-api=${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}
      #
      # For AWS ECS:
      # - name: Deploy to ECS
      #   uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      #   with:
      #     task-definition: task-definition.json
      #     service: my-api-service
      #     cluster: my-cluster
      #
      # For Helm:
      # - name: Update Helm values
      #   run: |
      #     yq eval '.image.tag = "${{ needs.build.outputs.version }}"' -i values.yaml

      - name: Deployment placeholder
        run: |
          echo "ðŸš€ Deployment triggered"
          echo "Image: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}"
          echo ""
          echo "TODO: Add actual deployment steps for your infrastructure"

  # ---------------------------------------------------------------------------
  # Deploy to Staging (manual trigger)
  # ---------------------------------------------------------------------------
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event.inputs.environment == 'staging'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Staging
        run: |
          echo "ðŸš€ Deploying to Staging"
          echo "Image: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}"
          # TODO: Add staging deployment steps

  # ---------------------------------------------------------------------------
  # Deploy to Production (manual trigger with approval)
  # ---------------------------------------------------------------------------
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event.inputs.environment == 'production'
    environment:
      name: production
      # Requires manual approval (configure in repo settings)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Production
        run: |
          echo "ðŸš€ Deploying to Production"
          echo "Image: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}"
          # TODO: Add production deployment steps
